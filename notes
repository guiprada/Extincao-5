- TESTAR ORDEM DA FILA DA ESPECIACAO - ALEATORIA E INVERSA(COMO ERA)
- TESTAR NEAT INICIANDO TUDO COM PESO 1 para garantir que sera ativado!
- ATUALMENTE OS PESOS PODEM SER NULOS E A MUTACAO E MULTIPLICATIVA!(IMPLEMENTAR MUTACAO ADITIVA!)
- TESTAR NEAT COM PESOS NEGATIVOS
- TESTAR NEAT COM TUDO ALEATORIO
- pesquisar bug ipairs x #self._layers
	https://stackoverflow.com/questions/23590885/why-does-luas-length-operator-return-unexpected-values
	Background: Tables in Lua are internally divided into array part and hash part. That's an optimization. Lua tries to avoid allocating memory often, so it pre allocates for the next power of two. That's another optimization.

	When the last item in the array part is nil, the result of # is the length of the shortest valid sequence found by binsearching the array part for the first nil-followed key.
	When the last item in the array part is not nil AND the hash part is empty, the result of # is the physical length of the array part.
	When the last item in the array part is not nil AND the hash part is NOT empty, the result of # is the length of the shortest valid sequence found by binsearching the hash part for for the first nil-followed key (that is such positive integer i that t[i] ~= nil and t[i+1] == nil), assuming that the array part is full of non-nils(!).
	So the result of # is almost always the (desired) length of the shortest valid sequence, unless the last element in the array part representing a non-sequence is non-nil. Then, the result is bigger than desired.
- melhorar resolucao de tempo
- adicionar velocidade constante como opcao
- Adicionar servidor de populacao
	- Adicionar suporte a headless
- todas as configuracoes em lua
- remove unused neurons from NEAT fenotype
- implementar funcoes que nao usam "self" para AutoplayerAnnModes.lua
- implementar gameplay data capture and offline learning
- implementar teste com o dataset mnist
- NEAT para fantasmas
- implementar load and save population
- Add map and population loading
- add the pheromone thingy :) -- WTF?
- tecnicas para aumentar diversidade.
	-(modificar totalmente um gene no crossover)
	- Valor de corte para especiacao diminui com o tempo(proporcional a geracao, ou a contagem de geracoes sem especiacao, ou a quantidade de especies ativas)
		- taxa de mutacao e adicionar neuronios e links dinamica.
- visualizador de topologia do neat(funcionamento em tempo real?)
- serializar ANN neat


- Fantasmas capturados tem um delay para voltarem(pressao para captura)
- Player spawnan em um linha onde nao ha spawn de pilulas nem fantasmas
- Melhorar robustez do sistema de log
- Object pools

	- Testar cooevolucao
	- Testar adaptabilidade da populacao uma vez convergida



	- layout em uma configuracao lua

----------------- DONE
- implementar NEAT
	- verificar se o link ja existe
- split population_size and _history size
- Very simple, look at front and rotate_left(or rotate_right)

----------------- CORRUPTED
1671132502 B2
1670698681 B3
1667082412 NB4



-----------------------------------------
----------------- NOTES
** to adapt this to ghosts we could get a next position only when out of corridors **
** should mutation be only  for greater amplitude?(since crossover always diminishes it) **

- BASELINE, um algoritmo especialista que foge quando vulnerável e ataca quando oportuno, mas não sai da rota para procurar pilulas ou fantasmas.
- BASELINE_PILL, um algoritmo especialista que foge quando vulnerável e ataca quando oportuno, desvia da rota para procurar pilulas mas não para fantasmas.
- BASELINE_PILL_GHOST, um algoritmo especialista que foge quando vulnerável e ataca quando oportuno, desvia da rota para procurar pilulas e capturar fantasmas.
- BASELINE_RANDOM, um algoritmo especialista que foge quando vulnerável e ataca quando oportuno, caso a rota atual seja ruim, assume uma outra rota aleatoriamente.
- BASELINE_COLLIDE_RANDOM, um algoritmo especialista caso tenha ocorrido uma colisão, assume uma outra rota aleatoriamente.
- BASELINE_FULL_RANDOM, um algoritmo especialista que, assume uma outra rota aleatoriamente.
- BASELINE_VALID_RANDOM, um algoritmo especialista que foge quando vulnerável e ataca quando oportuno, caso a rota atual seja ruim, assume uma outra rota válida aleatoriamente.
- BASELINE_VALID_FULL_RANDOM, um algoritmo especialista que, assume uma outra rota válida aleatoriamente.



- em ordem de capacidades
*- BASELINE_FULL_RANDOM. (nenhuma capacidade)
*- BASELINE_VALID_FULL_RANDOM. (capacidade de escolher uma rota valida)
*- BASELINE_COLLIDE_RANDOM. (detecta colisão)
*- BASELINE_RANDOM. (capacidade de fugir e atacar)
*- BASELINE_VALID_RANDOM. (capacidade de fugir e ataque oportuno e escolher rotas validas)
*- BASELINE. (capacidade de fugir e ataque oportuno, nao desvia rota para capturar)
*- BASELINE_PILL. (capacidade de fugir e ataque oportuno, desvia rota para capturar pilulas)
*- BASELINE_PILL_GHOST. (capacidade de fugir e ataque oportuno, desvia rota para capturar)